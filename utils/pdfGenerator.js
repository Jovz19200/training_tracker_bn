const PDFDocument = require('pdfkit');
const fs = require('fs');
const path = require('path');

// Generate a certificate PDF
exports.generateCertificatePDF = async (certificateData) => {
  return new Promise((resolve, reject) => {
    try {
      const { user, course, certificateNumber, issueDate } = certificateData;
      
      // Create a document
      const doc = new PDFDocument({
        size: 'A4',
        layout: 'landscape',
        margins: { top: 50, bottom: 50, left: 50, right: 50 }
      });
      
      // Set the output file path
      const filePath = path.join('uploads', 'certificates', `${certificateNumber}.pdf`);
      const writeStream = fs.createWriteStream(filePath);
      
      // Pipe the PDF to the file
      doc.pipe(writeStream);
      
      // Add certificate content
      doc.font('Helvetica-Bold').fontSize(30).text('Certificate of Completion', { align: 'center' });
      doc.moveDown();
      doc.font('Helvetica').fontSize(16).text('This is to certify that', { align: 'center' });
      doc.moveDown();
      doc.font('Helvetica-Bold').fontSize(24).text(`${user.firstName} ${user.lastName}`, { align: 'center' });
      doc.moveDown();
      doc.font('Helvetica').fontSize(16).text('has successfully completed the course', { align: 'center' });
      doc.moveDown();
      doc.font('Helvetica-Bold').fontSize(20).text(`${course.title}`, { align: 'center' });
      doc.moveDown();
      doc.font('Helvetica').fontSize(14).text(`Issued on: ${new Date(issueDate).toLocaleDateString()}`, { align: 'center' });
      doc.moveDown();
      doc.font('Helvetica').fontSize(12).text(`Certificate Number: ${certificateNumber}`, { align: 'center' });
      
      // Add signature line
      doc.moveTo(200, 600).lineTo(400, 600).stroke();
      doc.font('Helvetica').fontSize(12).text('Authorized Signature', 250, 610);
      
      // Finalize the PDF and end the stream
      doc.end();
      
      writeStream.on('finish', () => {
        resolve(filePath);
      });
      
      writeStream.on('error', (error) => {
        reject(error);
      });
    } catch (error) {
      reject(error);
    }
  });
};

// Generate a report PDF
exports.generateReportPDF = async (reportData) => {
  return new Promise((resolve, reject) => {
    try {
      const { title, data, generatedBy, generatedDate } = reportData;
      
      // Create a document
      const doc = new PDFDocument();
      
      // Set the output file path
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const filePath = path.join('uploads', 'reports', `${title.replace(/\s+/g, '-')}-${timestamp}.pdf`);
      const writeStream = fs.createWriteStream(filePath);
      
      // Pipe the PDF to the file
      doc.pipe(writeStream);
      
      // Add report header
      doc.font('Helvetica-Bold').fontSize(20).text(title, { align: 'center' });
      doc.moveDown();
      doc.font('Helvetica').fontSize(12).text(`Generated by: ${generatedBy}`, { align: 'left' });
      doc.font('Helvetica').fontSize(12).text(`Date: ${new Date(generatedDate).toLocaleDateString()}`, { align: 'left' });
      doc.moveDown();
      
      // Add report data
      doc.font('Helvetica-Bold').fontSize(14).text('Report Data', { align: 'left' });
      doc.moveDown();
      
      // Process and add data based on report type
      // This is a simple example - actual implementation would depend on report structure
      if (Array.isArray(data)) {
        data.forEach((item, index) => {
          doc.font('Helvetica-Bold').fontSize(12).text(`Item ${index + 1}:`);
          Object.entries(item).forEach(([key, value]) => {
            doc.font('Helvetica').fontSize(10).text(`${key}: ${value}`);
          });
          doc.moveDown();
        });
      } else if (typeof data === 'object') {
        Object.entries(data).forEach(([key, value]) => {
          if (typeof value === 'object') {
            doc.font('Helvetica-Bold').fontSize(12).text(key);
            Object.entries(value).forEach(([subKey, subValue]) => {
              doc.font('Helvetica').fontSize(10).text(`${subKey}: ${subValue}`);
            });
          } else {
            doc.font('Helvetica').fontSize(10).text(`${key}: ${value}`);
          }
          doc.moveDown();
        });
      }
      
      // Finalize the PDF and end the stream
      doc.end();
      
      writeStream.on('finish', () => {
        resolve(filePath);
      });
      
      writeStream.on('error', (error) => {
        reject(error);
      });
    } catch (error) {
      reject(error);
    }
  });
};